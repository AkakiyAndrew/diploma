Бердник Михаил Геннадиевич +380957435495
Мороз Борис Иванович
Розробка ігрового додатку для адаптації дій гравця з використанням бібліотек RayLib v3.5, OpenMP 2.0 на мові C++

по игре: 

1. Суть самой игры: игроку в начале дается база (квадратная штука внизу рисунка) и какое-то количество энергии. Игрок может строить ядра (мелкие постройки со светло-синим покрытием вокруг), они регулярно дают игроку энергию в зависимости от того, сколько территории покрывают. Энергия тратится на создание новых построек. Игрок может "продавать" свои ненужные постройки, получая ~75% от их стоимости.

Также игрок может строить три типа турелей: легкая ракетная (бьет немного, но часто), тяжелая лазерная (бьет редко, но сильно) и зенитное ПВО (единственная, которая может подбивать воздушных юнитов противника).
Л - огнемет, бьет по площади, часто и немного.
Т - без изменений
В - без изменений
Турели можно строить только на покрытии вокруг ядер.

Задача игрока - уничтожить главный улей Жучар (крупная темно-красная штука сверху рисунка). Улей регулярно плодит ульи поменьше (розовые штуки), которые создают для Жучар еду. Создание новых ульев не требует затрат еды, и происходит на незанятых ядрами и другими ульями местах. Занятое место обозначается темно-фиолетовой слизью, которая дает еду в зависимости от занятой площади и ускоряет передвижение Жучар по ней.

Еда тратится главным ульем для создания жучар, которые идут в атаку на игрока. Их три типа: таракашка (слабый, шустрый, дешевый), жук (сильный, медленный, дорогой), комар (средний по силе и цене, но летает).

Возможно, Жучары и игрок смогут улучшать своих юнитов, но эту идею оставлю на потом.

2.1 Machine Learning: собственно, главная идея и фишка состоит в том, чтобы прицепить машинное обучение Жучарам, дабы те адаптировались к действиям игрока. Адаптация будет выглядеть следующим образом:
	1) Улей наплодил группу Жучар, допустим, 10 таракашек, 3 жука и 1 комара.
	2) У игрока есть 4 ракетницы и 1 лазерная турель.
	3) Во время боя турели легко перебили таракашек на подходе, но жуки успели нанести какой-то ущерб, а комар и вовсе остался жив и безнаказанно наносит урон постройкам игрока.
	4) После боя Жучары подсчитали то, сколько урона нанес и получил каждый тип Жучар, и подкрутили соотношение своих войск.

После этого цикл начинается сначала, но в этот раз улей плодит, например 0 таракашек, 4 жука и 5 комаров.


2.2 Поиск пути: Жучары будут стараться обходить места, где их было убито много, и попадать в те места, где они смогли нанести много ущерба. Как эту штуку реализовать я уже по большей части знаю (есть отдаленный по смыслу рабочий прототип), но будут свои нюансы. Для каждого типа жуков своя "карта урона". Карта урона должна учитывать бонус от скорости передвижения (уменьшает стоимость клетки на какой-то процент/количество при построении пути).

Циклы обучения должны происходить спустя какое-то количество волн атак, чтобы обучение не происходило слишком быстро.
Сделать режим "глупого" ИИ, который будет лишен управления нейросетью, и просто идет напролом - для получения данных о "глупых" действиях, чтобы сравнить с "умными".

Идея: сделать базовое убывание отрицательной стоимости клетки, обусловленной потерями, и бонусов полученных за нанесенный урон (какой-то небольшой процент).

ИДЕЯ: игрок изначально может строить по 1 зданию каждого типа за раз, но может увеличить это количество, построив спец. здание/выполнив в базе улучшение.
Улей жуков плодит жуков по таймеру, ИЛИ пока не накопится некая крит. масса еды (кол-во крит. массы зависит от размеров карты?).

Карты сделать разных размеров, с препятствиями. Интересным будет взглянуть на поведение жуков на сложных картах, где игрок появляется в центре, в окружении.
Идея: добавить разные типы тайлов (болота, вода, горы, и т.п.), которые будут проходимы, но замедляют движение. Реализовать как базовый отрицательный бонус при рассчете пути движения.

Генерация мира: генерировать Перлином, судя по высотам выдавать тип тайла: >75% - mountain, <40% - lake, >50%&<75% - tree, по типу того
сделать опции с предпросмотром возможной локации (небольшую пикчу) и ползунками для параметров
При генерации показывать промежуточные результаты и прогресс
ФАКТ: зерно генерации выдает тот же результат, не зависимо от размера, йеей!

Карты изначально будут покрыты туманом войны, как для жуков, так и для игрока (будет отображено местонахождение главных баз сторон). Препятствия и типы местностей тоже не будут видны с начала, жукам придется случайно выбирать путь (дать неразведанной области приоритет?), разведывая маршруты к базе. Туман войны снимается насовсем с выбранной области (C&C-формат). Запихивать в нейросеть только те турели, что были разведаны.

Поиск пути: строится один раз прямиком к базе игрока, перестройку делать только если наткнется на неразведанный непроходимый участок (или локально переходить жучарой, хотя это хуже, кажется), при нахождении противника в радиусе атаки - атаковать его (постройка нового маршрута?).

Рассчет поиска пути: Understanding Goal-Based Vector Field Pathfinding, делать перерасчет карты векторов для каждого типа движимого юнита каждый цикл рассчета пути.

Проводить рассчет карты векторов пути в другом потоке

Модели столкновений жуков учитывают только жуков такого же типа, строения и непроходимые тайлы.

Идея: формировать общую текстуру тайлов (без построек) после каждого построенного/уничтоженного здания.
Графика: оставлять долгоживущие лужи крови в местах гибели жуков, для отображения мест которые они будут избегать.

Баланс: максимум турелей зависит от кол-ва ядер?
Турели тратят энергию на зарядку(!)

Распределение энергии: по приоритету, сперва перезарядка турелей, ремонт, затем строительство. Дать возможность игроку выставить приоритет на постройки, дабы они получали энергию первыми в очереди.

Рассчет отступания слизи происходит раз в N циклов рассчета.

Рассчет следующего места для мелкого улья - по тем же принципам, что и поиск пути (но с ограничениями по видимости и т.п.)

Идея по турелям: скорость постройки турели повышается, если где-то еще демонтируется однотипная турель.
ИЛИ
Демонтаж превращает турель в мобильную её версию (не могущую стрелять), которую игрок может развернуть в другом месте.
И/ИЛИ
турели строятся только главной базой, а затем разворачиваются возле ядер

3.1 Машинное обучение для стороны Игрока. 
Добавить его также и для этой фракции, нейросеть должна выдавать предпочтительный тип следующей турели, ставящийся на фронтире в соответствии с составленной картой частоты пробегания жуков (по карте на каждый тип). Главная сложности - научить бота ставить турель там где надо, и можно это сделать (с использованием карты доступной местности).

Для отчета дипломной работы потребуются графики полученных/затраченных ресурсов, полученного нанесенного урона, боевой эффективности, количества наплодившихся жучар и т.п. Необходимо вести учет всего этого и выводить в виде удобных накладывающихся друг на друга графиков.
Режимы для показа карты с поиском пути, клетками где получен урон, графики всяких показателей и текущие выводы нейросети.
Сделать отдельно тестирование нейросети, с простым обсчетом боев, выводом результатов и текущих показателей и т.п.

атакующие юниты/турели: если есть нацеливание на противника - атаковать его (передавать в функцию атаки атакующего и цель, чтобы удалить нацеливание если нужно), если нет - проверять есть ли в округе противник, если да - нацелится на него. Проверка идет в том числе на то, есть ли противник в зоне прямой видимости - сквозь скалы стрелять нельзя.

спрайты - пиксельные?
звуки улья - микрофон в овсянке
анимация опухоли - аки бьющееся сердце, извергающее слизь на поверхность
тайлсеты сделать, вид тайлов зависит от присутствия однотипных тайлов вокруг
к подключенным турелям по земле от ядер проводятся "энергодорожки" аки генераторы к заводам в супримке, бордово-красные, пульсирующие когда запитанны(зарядка/починка/строительство)
матрица расчета пути расчитывается раз в n-ый цикл, с учетом перемен в разведке и боях, а расчет пути производится на ходу каждым жуком(по тому методу)
для GUI отдельные классы, с методами "Тыкнуто"
проводить рассчет, тыкаю я по полю или интерфейсу, если по интерфейсу - перебрать массив с каждой кнопкой и спрашивать "Ты находишься по этим координатам?"
строить можно лишь в радиусе экспансии ядер и вне тумана войны, опухоли - где угодно(???)
кнопка отображения областей экспансии жуков и игрока (Tab, например)
напалм поджигает луга и леса, превращая их в пепелище 
при наведении выводить название и описание типа ландшафта тайла, помимо постройки что на нем
ТИПЫ ЛАНДШАФТА: в тетради
в настройках разные типы действия ИИ: посылать всех кратчайшим путем без учета местности/без учета боевой обстановки/без отличия карт урона для типов жуков

ВАЖНО: пушки заряжаются только у своих эконом. построек в стационарном (или и мобильном?) виде, но разворачиваться в боевой режим могут и вдали от ядер, однако ядра на слизи не построить, как и новые пушки  

сделать json-файлик с базовыми настройками юнитов, которые загружаются по умолчанию в игру, в игре спец. менюшку для балансирования параметров юнитов перед игрой и сохранением конфига в виде отдельного файлика,
из этих настроек брать параметры юнитов для конструктора в GameActors

экономические тайлы отрисовывать как вещества в ONI, тайлы складываются в маску, а она накладывается на анимированный мегатайл(??)

ЭКСПАНСИЯ:
карта экономических тайлов генерируется заранее: 0 - экспансия невозможна, 1 - экспансии нет, но возможна, 2 - экспансия проведена и рядом есть источник экспансии, 3 - если экспансия проведена, но рядом нет источника (тайлы, которые будут убывать в отдельном цикле проверки, если рядом с ними будет 2 или меньше соседа), или другие числа по типу byte, чтобы легче хранить было и запихивать в файл сохранения.
экспансию для обоих сторон проводить раз в n циклов, n указывать в настройках(раз в 3 цикла?)
при уничтожении источника экспансии делать перерасчет всех однотипных тайлов экспансии (чтобы определить, какие будут убывать)
убывание: сделать вектор с координатами тайлов, чтобы за раз удалить все, в него добавлять по признаку: проверять каждый тайл без источника, если возле него менее трех тайлов такого же типа

экспансия ядер быстрее расширяется, но и быстрее уходит. у опухолей наоборот

сделать класс с картами с методами по типу getCreepAmount()/getTerrainType, хранящий в себе карты, загружающий и т.п.
возможно, обьединить с настройками юнитов, дабы все хранить в одном месте, и назвать GameMap
хранить будет: карты, массивы юнитов, методы доступа к картами и обновления/отрисовки всего игрового (кроме, пожалуй, интерфейса)

GUI: для элементов делать точку отсчета (левый верхний край) и высоту+ширину, дальнейшее расчитывать на ходу

осмотреть рекуррентные, ядерные нейронки - но опробовать с персептронов

ТАЙЛЫ: попробовать генерировать тайлы воды, песка, камней и т.п. на ходу с помощью Перлина (карту высот множить на цвет тайла)
наделать каждому типу местности несколько вариаций тайлов, чтобы лучше смотрелось
крип: та 1024*1024 текстура идеальна, надо подогнать размер и нарезать тайлсет
отрисовка тайлсета: вычислять индекс соседей (как в тех статьях), по нему обращаться к словарю (найти как делать) и выбирать нужную текстуру

ЭКСПАНСИЯ: улей создает новые опухоли так: с каждой опухоли берутся тайлы по периметру круга радиусом в радиус экспансии, перебираются, первая что не имеет слизи - получает строящуюся опухоль (учитывать карту получения/нанесения урона?) 

АНИМАЦИЯ ТАЙЛОВ: в GameData вести общий счетчик для анимации текстур, и по нему определять, какой кадр тайла рисовать(распихать текстуры по массивам, доступ к ним давать по номеру кадра)

ПОИСК ПУТИ: летающие летают где хотят с одинаковой скоростью, тяжелые не могут ходить по скалам, легкие не могут по скалам и глубокой воде. Модификатор скорости от типа местности также разнится для всех типов жучар.
сделать:
учитывать слизь и туман войны, пересчитывать каждый раз когда пересчитывается область видимости
туман войны: рисовать черное полотно, если область видна - рисовать на ней тайл и юнитов на ней
для тайлов с туманом войны ставить цену предыдущего тайла без увеличения цены за счет расстояния, типа местности и т.п.

КОЛЛИЗИИ:
проверить наличие непроходимых тайлов вокруг, отпихнутся от них
получить вектор с актерами вокруг (радиус текущего юнита*2), отпихнутся от каждого
если вышел за границы карты - жестко выставить координаты в границах карты
(спереть принцип у Игоря)

ОПТИМИЗАЦИЯ: при приближении камеры ниже определенного уровня отрисовывать лишь те тайлы и актеров, которых камера захватывает
при отдалении отрисовывать схематичные местность (генерировать заранее, как в превью генерации местности) и актеров на ней
перерисовка экономических тайлов не должна быть затратной - регенерируется крохотная текстура, вместо одной огромной

ГРУППА: в GameData сделать массив указателей выбранных юнитов, выбор идет по алгоритму: игрок выделяет область, выделяются все юниты пересекающие прямоугольник выбора (функция Intersect рейлиба), выбираются только турели (перебор по условию if(type==ActorType::LIGHT_TURRET && ...)), им присваивается свойство "isChoosen=true", при ПКМ с не-нулевым массивом выбранных юнитов им отдается приказ на передвижение/особая кнопка для развертывания

БАЛАНС: турели вне зерослоя тратят энергию на передвижение, если её нет - турель не сдвинется с места и не сможет сменить режим на стационарный/мобильный ИЛИ они тратят энергию на движение по слизи

КОНСТРУКТОРЫ: создавая, например, турель - каждый конструктор смотрит на свою "часть" конфига (которая хранится в памяти, нужен еще один класс, выдающий параметры в зависимости от поданого типа актера)

КОНФИГУРАЦИЯ: (настройки параметров юнитов и прочего такого) - map<ActorType, map<std::string, int>>, хранящаяся в GameData

НЕЙРОСЕТЬ: перед началом игры прогонять симуляцию боя для предварительного обучения нейросети
для обучения во время игры попробовать сохранять последние несколько записей боевой эффективности и учить нейросеть на них

ОБНОВЛЕНИЕ ЮНИТОВ: если жук после какого-то времени нахождения цели не может до неё добежать, он будет пробовать найти новую цель кроме текущей

СОСТОЯНИЕ ЮНИТОВ:
Строения - ONLINE(экспансия, строительство, проверка на ), UNDER_CONSTRUCTION(проверка), OFFLINE(попытки )

ПОДКЛЮЧЕНИЕ ПОСТРОЕК:
дать классу Constructor вектор connected с указателями на Connectable, при вызове Destroy()/деструктора обнулить указатели parent всех Connectable/вызвать у них метод Disconect()
дать Connectable метод TryConnect(), вызываемый в Update() если указатель parent нулевой, если не вышло - переводить состояние Connectable в OFFLINE, при котором в Update() будет вызываться TryConnect() (возможная оптимизация: делать вызов только при достройке нового Constructor, который будет дергать TryConnect() у всех Connectable в радиусе подключения)

СТРОИТЕЛИ: имеют показатель buildPower - сколько ресурса можно потратить за один тик строительства

турели могут монтироваться не только на конкретной клетке, монтаж просто означает что они стают неподвижны

план: турели, перезарядка, боевой цикл, поиск противника для жучар, поправить steering для всех прочих юнитов (и вражеских)
добавить состояние "демонтаж", чтобы занимало время и отрисовывать анимацию?

Vector2Angle - для углов

в Update при смене состояния задается текущая ссылка Animation*, которые хранятся в game как map вызываемые по типу актера и состоянию

переделать Hit: он должен быть внутри GameData, чтобы мог удалять тех актеров, чье HP дойдет до нуля

обнулять указатели на убитых юнитов, дабы потом удалять их из вектора?
если да - нужно ввести проверки на ноль при каждой итерации 

Destroy() общий для каждого актера - добавлять в вектор последний затемненный спрайт убитого актера (или просто отдельные текстуры)

отдельный вектор для турелей, цикл отрисовки перед юнитами для турелей: если имеют 

Игровой цикл:

каждому актеру дать метод Draw(), отрисовывать поочередно:

ИДЕЯ: отрисовывать только тех, что вне тумана войны и(??) внутри окна камеры

1) ландшафт
2) экономические тайлы (анимировать слизь аки старкрафт, а энергоповерхность переливчатой)
3) обломки построек (жучиные в том числе - обломки и жучиные потроха будут иметь свой слой?)
4) турели с их подключениями к ядрам
5) ядра с их подключениями
6) юниты с их атаками и т.п.

пишем 2.1 и 2.2 (пункты в методичке), без маркетинга и прочего

q - передбачуване число операторів (кол-во строк строк)
p - коефіцієнт кореляції програми в ході її розробки (коррекции, не корреляции), значает сложности связанные с правками, значение от 0.05 до 0.1
C - коефіцієнт складності програми, сложность по отношению к "стандартной задаче", насколько понятно и адекватно выставили задачу, значение от 1.25 до 2.0
B  - коефіцієнт збільшення витрат праці внаслідок недостатнього опису задачі, от 1.2 до 1.5

почасовая плата программиста - найти в интернете среднюю зарплату программиста, указать ссылку на найденный ресурс
оплата машиночасов - плата за электроэнергию, амортизация, указывать ссылки(?)
коефициент квалификации программиста, по показателями: до двух лет квалификации - 0.8, 2-3 года - 1.0, 3-5 лет - 1.1-1.2, 5-7 - 1.3-1.4, учитываются даже некоммерческая занятость и "для себя/друзей"

Bk- число виконавців - по кол-ву пишущих этот диплом (в одиночку/в группе)

последнее что надо считать - "Очікуваний період створення ПЗ" на шестой странице

Очікуваний період створення ПЗ - не должен быть больше 10 месяцев

в Висновках писать, мол, рассчитали это и это, итоговая цена такая-то



В ДИПЛОМ: запихать причесанную диаграмму классов, ссылки и описание к использованным библиотекам, технологиям (ООП, OpenMP, PerlinNoise, RayLib и т.д.)
расписать, что компонование одной большой текстуры поверхности занимает слишком много памяти, рисовать все тайлы по одиночке слишком медленно, поэтому был выбран промежуточный вариант - рисование тайлов, что входят в область видимости камеры, но с определенного уровня масштаба отрисовывается схематичная карта 

более подробно расписать принцип работы шума Перлина

2 рецензии, список файлов на диске, титулки, 1.3 (или какой он там), вступ

(для презентации?) про цель диплома изначальную: создать систему ИИ, которая будет адаптироваться под действия игрока,
а игрок уже сам пусть барахтается как хочет

в диплом:
в мат. методы - о собираемой статистике и возможном применении персептрона для более эффективного распределения ресурсов
про состояния юнитов (с примерами кода и т.п.)
про алгоритм поиска пути, с сопутствующими алгоритмами
про генерацию ландшафта Перлином
про общую архитектуру игры: цикл рассчета:
	Инициализация(разовая, всякие переменные, карты и т.п.)

	Цикл, пока не-нужно-закрывать:
		Рассчет(рассчет положения юнитов, курсора, нажатых клавиш и т.п.)
			В зависимости от состояния игры(???):
			-в меню
			-в игре
		Отрисовка(тайлы, юниты, GUI)

	Деинициализация()


